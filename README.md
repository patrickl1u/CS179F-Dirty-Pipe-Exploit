# CS179F Final Report

## CVE-2022-0847 (Dirty Pipe)

Prepared by Patrick Liu and Nitya Gandu for CS179F

https://dirtypipe.cm4all.com/

### Intro
---

CVE-2022-0847 is a vulnerability in the Linux kernel due to some uninitialized pipe flag variables which allows a method for arbitrary write to an unpriviledged user.

### Vulnerability 

Since Linux 5.8, some changes were made to how system calls would use pipe buffers. This meant including explicit flags to enable or disable certain states of operation.

This type of vulnerability is categorized as CWE-457: Use of Uninitialized Variable. The function `copy_page_to_iter_pipe()` does not initialize variable responsible for flags. This means that if the same pipe is utilized multiple times, some data may be present from previous usage. In other words, the function not initializing the variable for flags means the previous flags that were used could be reused.

When the flag `PIPE_BUF_FLAG_CAN_MERGE` is set, it instructs the system to write back the file to the disk. This feature is meant to allow for quick access to data in the page cache, and only write to disk if changes were made in the page cache. 

This flag would commonly be used for files a user has write access to. However, when the aforementioned function is called, it doesn't properly initialize the flags variable. This can lead to instances where a previous call's flags creates dirty data which the function interprets as a valid flag.

### Exploit
---

DirtyPipe uses the uninitialized variable vulnerability to gain arbitrary write by preparing a pipe with some data structures preloaded. The system call `splice()` will interpret the dirty pipe flag data and allow writing to a file, even if the user does not have write access to that file.

First, data is preloaded into a pipe to initialize the flag to write back to disk (`PIPE_BUF_FLAG_CAN_MERGE`). This is done by writing to a file which the user controls. The data is drained out to prepare the pipe for the exploit payload.

Next, some checks are performed:
- The user needs read permissions to be able to `splice()` data
- The exploit only works within a page as once a page boundary is crossed, a new page is utilized without the dirty data. 
- The write also cannot start at the page boundary, `splice()` needs at least one byte of page data to splice a page into the pipe. 
- The file cannot be resized as the pipe will be expecting to write a certain amount of data to disk and is not in control.

Once all the checks are passed, the exploit can continue and call `splice()`. This prepares the target file to be written to.

Finally, data is written into the pipe. Because of `PIPE_BUF_FLAG_CAN_MERGE`, the written data is also written back to disk.

#### Exploit Adaptation

##### Approach 1: SSH
---

Rather than using `/etc/passwd` to gain elevated privileges, we explored alternative ways to utilize the exploit.

Our initial approach was to target `/etc/sudoers` but since unprivileged users do not have read access, this approach does not work. However, there are many other interesting files that unprivileged users can read.

Many important configuration files exist inside `/etc`. This includes programs like `grub`, `dhclient` and `systemd`. Rather than target `systemd`, we chose to try and use `/etc/crontab` to gain a root shell as reloading changes made to any daemons could pose an issue.

However, we still ran into similar issues with `/etc/crontab`. Even though we were able to modify the files, we could not force the changes to take effect. Without using `crontab -e`, we were not able to properly install a script into `crontab`.

Another approach that we considered was with `setuid` and `setgid`. However this is also difficult as it involves opening the filesystem directly. It would be hard to navigate through this file, and it would involve headache-inducing topics like [inodes](https://stackoverflow.com/questions/37881664/c-function-to-modify-inode). While technically feasible (since we have arbitrary write to even read files) it may prove difficult to realize.

The approach that succeeded was through `sshd`. Through `/etc/ssh/sshd_config`, we were able to enable root login through `ssh`. By specifying a public key we control for login as root, we are able to `ssh` into `localhost` as root.

The changes to `/etc/ssh/sshd_config` are as follows:
```
StrictModes=no
PermitEmptyPasswords=yes
PermitRootLogin=without-password
AuthorizedKeysFile=/home/user/.ssh/a
```

The file `/home/user/.ssh/a` is a file defined the same as the file typically found in `~/.ssh/authorized_keys`.

One caveat about this approach is that `sshd` must be restarted to reload the changes to the configuration file. To do this, one can run `systemctl restart sshd` with the proper permissions. For us, we do not yet have those permissions so we must force a restart of the system to have the changes take place. While we tried various approaches including shellcode, none worked. This approach as a result is not a complete end-to-end exploit.

##### Approach 2: `/etc/groups`
---

After some thought, it became quickly apparent that none of the `sshd` workarounds to try and reboot were relevant. An alternative method to gain elevated permissions was to simply give ourselves `sudo`. We must have at least read permissions, which we do not have to `/etc/sudoers`. However, `/etc/group` is readable. 

By editing the file to include ourselves in the `sudo` group, we're able to gain local privilege escalation. To have these changes take place, we just need to start a new user session. This can be achieved by logging in again to the system (locally or remotely).

### Lessons Learned
---

A lesson learned from this was that sunk-cost fallacy can definitely apply to computer science. The SSH approach to try and gain elevated permissions was stalled by the fact that the changes wouldn't be applied until reboot (or restart of `sshd`). Approach 2 using `/etc/groups`—which is much simpler—became apparent once Approach 1 was abandoned. Time would have been better spent at looking at different attack vectors rather than perfect one approach.

## References

https://www.hackthebox.com/blog/Dirty-Pipe-Explained-CVE-2022-0847

https://safe.security/resources/blog/linux-dirty-pipe-cve-2022-0847/
